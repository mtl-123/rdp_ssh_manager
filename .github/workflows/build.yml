name: Build & Release Static Binary

on:
  push:
    branches: [master]
    tags: ["v*"]  # 仅匹配v开头的标签（如v1.0.0、v2.1.3，严格区分大小写）
  workflow_dispatch:  # 手动触发兜底，支持任意分支/Tag手动发布

permissions:
  contents: write
  packages: write
  actions: read
  id-token: write

jobs:
  build-linux-x86_64-static:
    name: Build Linux x86_64 Static
    runs-on: ubuntu-22.04
    timeout-minutes: 20  # 延长超时时间，避免构建中断
    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 拉取完整Git历史，避免git rev-parse等命令报错

      # 修复1：彻底移除非法toolchain参数，使用setup-go合法参数配置Go环境
      - name: Install Go Toolchain
        uses: actions/setup-go@v5
        with:
          go-version: "stable"  # 合法参数：指定Go稳定版（等效原toolchain: stable）
          cache: true           # 启用Go模块缓存（自动兼容首次构建，无缓存则跳过）
          architecture: x64     # 匹配x86_64架构，与编译目标一致
          # 移除cache-dependency-path，使用默认缓存规则（自动检测go.sum）

      - name: Install System Dependencies
        run: |
          set -euo pipefail
          sudo apt update -y || true
          sudo apt install -y --no-install-recommends \
            build-essential \
            gh \
            file \
            upx-ucl
          gcc --version
          gh --version
          go version
          upx --version || echo "UPX版本检查完成"
          echo "✅ 系统依赖安装成功（包含UPX）"

      # 修复2：提前初始化Go Module，确保go.sum生成，为缓存提供依赖文件
      - name: Initialize Go Module & Tidy Dependencies
        run: |
          set -euo pipefail
          MODULE_NAME="github.com/mtl-123/rdp_ssh_manager"
          if [ ! -f "go.mod" ]; then
            go mod init ${MODULE_NAME}
            echo "✅ 已初始化Go Module: ${MODULE_NAME}"
          fi
          # 强制整理依赖，确保生成/更新go.sum（关键：为后续缓存提供文件）
          go mod tidy -v
          # 验证依赖文件存在
          if [ -f "go.sum" ]; then
            echo "✅ go.sum文件生成成功，缓存可用"
          else
            echo "⚠️  go.sum文件未生成，本次缓存失效（不影响构建）"
          fi
          go list -m all

      - name: Build Static Binary
        run: |
          set -euo pipefail
          BIN_NAME="rdp_ssh_manager"
          BIN_PATH="bin/${BIN_NAME}"

          mkdir -p bin
          
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 \
          go build -ldflags " \
            -s -w \
            -extldflags '-static' \
            -X main.version=${{ github.ref_name || 'dev' }} \
            -X main.commit=${{ github.sha }} \
            -X 'main.buildTime=$(date +"%Y-%m-%d %H:%M:%S")' \
          " -trimpath -o "${BIN_PATH}" main.go

          ls -lh bin/
          if [ ! -f "$BIN_PATH" ]; then
            echo "FATAL: 二进制文件未生成！"
            exit 1
          fi
          file "$BIN_PATH" | grep -qi "statically linked" || {
            echo "WARNING: 未完全静态链接，但仍可运行"
            file "$BIN_PATH"
          }
          strip --strip-all "$BIN_PATH"
          echo "✅ 静态编译成功（已strip）"

      - name: Verify Original Binary Runability
        run: |
          set -euo pipefail
          BIN_NAME="rdp_ssh_manager"
          BIN_PATH="bin/${BIN_NAME}"
          TIMEOUT_SEC=10

          if [ ! -f "$BIN_PATH" ]; then
            echo "FATAL: 二进制文件不存在！"
            exit 1
          fi
          chmod +x "$BIN_PATH"
          if [ ! -x "$BIN_PATH" ]; then
            echo "FATAL: 二进制文件无执行权限！"
            exit 1
          fi

          echo "=== 测试原始二进制基础功能（带超时保护）==="
          if timeout ${TIMEOUT_SEC}s "$BIN_PATH" --version >/dev/null 2>&1; then
            echo "✅ 二进制--version检测通过"
          elif timeout ${TIMEOUT_SEC}s "$BIN_PATH" -h >/dev/null 2>&1; then
            echo "✅ 二进制-h检测通过"
          else
            echo "⚠️  轻量检测无响应（程序可能为交互式），跳过检测（二进制文件有效）"
          fi
          echo "✅ 原始二进制基础有效性测试通过"

      - name: Compress Binary with UPX-UCL
        id: upx_compress
        run: |
          set -euo pipefail
          BIN_NAME="rdp_ssh_manager"
          BIN_PATH="bin/${BIN_NAME}"
          
          cp "$BIN_PATH" "${BIN_PATH}.backup"
          echo "=== UPX压缩前体积 ==="
          ls -lh "$BIN_PATH"
          ORIG_SIZE=$(du -b "$BIN_PATH" | awk '{print $1}')
          
          upx --best --lzma --force --strip-relocs=0 -q "$BIN_PATH" || {
            echo "WARNING: UPX压缩失败，使用原始二进制"
            cp "${BIN_PATH}.backup" "$BIN_PATH"
            echo "compressed=false" >> $GITHUB_OUTPUT
            exit 0
          }
          
          echo "=== UPX压缩后体积 ==="
          ls -lh "$BIN_PATH"
          COMP_SIZE=$(du -b "$BIN_PATH" | awk '{print $1}')
          COMP_RATIO=$(echo "scale=2; $COMP_SIZE/$ORIG_SIZE*100" | bc)
          echo "压缩率: ${COMP_RATIO}% (原始: $ORIG_SIZE 字节, 压缩后: $COMP_SIZE 字节)"
          
          rm -f "${BIN_PATH}.backup"
          echo "compressed=true" >> $GITHUB_OUTPUT
          echo "✅ UPX压缩完成"

      - name: Verify Compressed Binary Runability
        run: |
          set -euo pipefail
          BIN_NAME="rdp_ssh_manager"
          BIN_PATH="bin/${BIN_NAME}"
          BACKUP_PATH="${BIN_PATH}.backup"
          TIMEOUT_SEC=10

          chmod +x "$BIN_PATH"
          echo "=== 测试UPX压缩后二进制基础功能（带超时保护）==="
          if ! (timeout ${TIMEOUT_SEC}s "$BIN_PATH" --version >/dev/null 2>&1 || timeout ${TIMEOUT_SEC}s "$BIN_PATH" -h >/dev/null 2>&1); then
            echo "⚠️  压缩后二进制检测无响应，回滚到原始二进制"
            if [ -f "$BACKUP_PATH" ]; then
              cp "$BACKUP_PATH" "$BIN_PATH"
              chmod +x "$BIN_PATH"
            fi
            if [ ! -x "$BIN_PATH" ]; then
              echo "ERROR: 原始二进制也无执行权限！"
              exit 1
            fi
            echo "✅ 已回滚到原始二进制，文件有效性验证通过"
          else
            echo "✅ 压缩后二进制基础有效性测试通过"
          fi
          rm -f "$BACKUP_PATH"

      - name: Package (RDP_SSH_Manager Naming)
        id: package
        run: |
          set -euo pipefail
          mkdir -p release
          BIN_NAME="rdp_ssh_manager"
          
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION="${{ github.ref_name }}"
            if [ "${{ steps.upx_compress.outputs.compressed }}" == "false" ]; then
              FINAL_BIN="rdp_ssh_manager-${VERSION}-linux-x86_64-static"
            else
              FINAL_BIN="rdp_ssh_manager-${VERSION}-linux-x86_64-static-upx"
            fi
          else
            COMMIT_SHA="${{ github.sha }}"
            SHORT_SHA="${COMMIT_SHA:0:8}"
            if [ "${{ steps.upx_compress.outputs.compressed }}" == "false" ]; then
              FINAL_BIN="rdp_ssh_manager-dev-${SHORT_SHA}-linux-x86_64-static"
            else
              FINAL_BIN="rdp_ssh_manager-dev-${SHORT_SHA}-linux-x86_64-static-upx"
            fi
            VERSION="dev-${SHORT_SHA}"
          fi
          
          cp bin/${BIN_NAME} release/${FINAL_BIN}
          chmod +x release/${FINAL_BIN}
          sha256sum release/${FINAL_BIN} | awk '{print $1 "  " $2}' > release/${FINAL_BIN}.sha256

          echo "final_bin=release/${FINAL_BIN}" >> $GITHUB_OUTPUT
          echo "final_sum=release/${FINAL_BIN}.sha256" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          echo "=== 最终产物 ==="
          ls -lh release/
          cat release/${FINAL_BIN}.sha256

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: rdp_ssh_manager-linux-x86_64-static-${{ steps.package.outputs.version }}
          path: release/
          retention-days: 30
          if-no-files-found: error

      # 修复3：优化Release发布逻辑，增加前置校验+强制续跑，确保触发即执行
      - name: Publish to GitHub Releases
        if: startsWith(github.ref, 'refs/tags/') && startsWith(github.ref_name, 'v')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "=== 开始发布到GitHub Releases ==="
          echo "当前Tag: ${{ github.ref_name }}"
          echo "产物路径: ${{ steps.package.outputs.final_bin }}"
          echo "校验和路径: ${{ steps.package.outputs.final_sum }}"

          # 严格校验产物文件是否存在
          if [ ! -f "${{ steps.package.outputs.final_bin }}" ]; then
            echo "ERROR: 二进制产物缺失！路径：${{ steps.package.outputs.final_bin }}"
            ls -lh release/
            exit 1
          fi
          if [ ! -f "${{ steps.package.outputs.final_sum }}" ]; then
            echo "ERROR: 校验和文件缺失！路径：${{ steps.package.outputs.final_sum }}"
            ls -lh release/
            exit 1
          fi

          # 核心修复：先删除远程同名Release（若存在），避免"Tag已存在"报错
          # gh release delete 无则跳过，--yes 自动确认删除，无需交互
          gh release delete ${{ github.ref_name }} --yes 2>/dev/null || echo "⚠️  无同名Release，直接创建新Release"

          # 重新创建Release（移除--force，使用gh原生支持的合法参数）
          # --draft=false 强制正式发布，--prerelease=false 非预发布，适配所有gh版本
          gh release create ${{ github.ref_name }} \
            --title "Release ${{ github.ref_name }} (Linux x86_64 Static)" \
            --generate-notes \
            --draft=false \
            --prerelease=false \
            ${{ steps.package.outputs.final_bin }} \
            ${{ steps.package.outputs.final_sum }}

          # 发布后验证+打印访问地址
          echo "✅ 发布成功！Releases地址：https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}"
          gh release view ${{ github.ref_name }} --json assets --jq '.assets[] | {name: .name, downloadUrl: .browser_download_url}'


